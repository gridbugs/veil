// Generated file. Do not edit!

macro_rules! spatial_hash_imports {
    () => {
{{#each imports}}
        use {{this}};
{{/each}}
    }
}

macro_rules! position_type {
    () => {
        {{position_type}}
    }
}

macro_rules! position {
    ($store:expr) => {
        $store.{{position_component}}
    }
}

macro_rules! spatial_hash_cell_decl {
    ($SpatialHashCell:ident) => {
        #[derive(Serialize, Deserialize)]
        pub struct $SpatialHashCell {
{{#each components}}
    {{#each fields}}
            pub {{aggregate_name}}: {{aggregate_type}},
    {{/each}}
{{/each}}
            pub entities: HashSet<EntityId>,
            pub last_updated: u64,

        }
    }
}

macro_rules! spatial_hash_cell_cons {
    ($SpatialHashCell:ident) => {
        $SpatialHashCell {
{{#each components}}
    {{#each fields}}
            {{aggregate_name}}: {{aggregate_cons}},
    {{/each}}
{{/each}}
            entities: HashSet::new(),
            last_updated: 0,
        }
    }
}

macro_rules! remove_implicit {
    ($self:expr, $entity_id:expr, $store:expr, $change:expr) => {

{{#each components}}
        if !$change.removals.contains($entity_id, ComponentType::{{name}}) {
    {{#if fields.f64_total}}
            if let Some(v) = $store.{{@key}}.get(&$entity_id) {
                $self.{{fields.f64_total.aggregate_name}} -= *v;
            }
    {{/if}}
    {{#if fields.count}}
            if $store.{{@key}}.{{#if type}}contains_key{{else}}contains{{/if}}(&$entity_id) {
                $self.{{fields.count.aggregate_name}} -= 1;
            }
    {{/if}}
    {{#if fields.set}}
            if $store.{{@key}}.{{#if type}}contains_key{{else}}contains{{/if}}(&$entity_id) {
                $self.{{fields.set.aggregate_name}}.remove(&$entity_id);
            }
    {{/if}}
        }
{{/each}}
    }
}

macro_rules! insert_implicit {
    ($self:expr, $entity_id:expr, $store:expr, $change:expr) => {
{{#each components}}
        if !$change.removals.contains($entity_id, ComponentType::{{name}}) {
    {{#if fields.f64_total}}
            if let Some(v) = $store.{{@key}}.get(&$entity_id) {
                $self.{{fields.f64_total.aggregate_name}} += *v;
            }
    {{/if}}
    {{#if fields.count}}
            if $store.{{@key}}.{{#if type}}contains_key{{else}}contains{{/if}}(&$entity_id) {
                $self.{{fields.count.aggregate_name}} += 1;
            }
    {{/if}}
    {{#if fields.set}}
            if $store.{{@key}}.{{#if type}}contains_key{{else}}contains{{/if}}(&$entity_id) {
                $self.{{fields.set.aggregate_name}}.insert($entity_id);
            }
    {{/if}}
        }
{{/each}}
    }
}

macro_rules! update_match_stmt {
    ($component_type:expr, $cell:expr, $entity_id:expr, $store:expr, $change:expr) => {
        match $component_type {
            ComponentType::Position => {
                $cell.remove_implicit($entity_id, $store, $change);
            }
{{#each components}}
            ComponentType::{{name}} => {
    {{#if fields.f64_total}}
                if let Some(v) = $store.{{@key}}.get(&$entity_id) {
                    $cell.{{fields.f64_total.aggregate_name}} -= *v;
                }
    {{/if}}
    {{#if fields.count}}
                if $store.{{@key}}.{{#if type}}contains_key{{else}}contains{{/if}}(&$entity_id) {
                    $cell.{{fields.count.aggregate_name}} -= 1;
                }
    {{/if}}
    {{#if fields.set}}
                if $store.{{@key}}.{{#if type}}contains_key{{else}}contains{{/if}}(&$entity_id) {
                    $cell.{{fields.set.aggregate_name}}.remove(&$entity_id);
                }
    {{/if}}
            }
{{/each}}
            _ => {
                // prevent the last_updated field from being changed
                continue;
            }
        }
    }
}

macro_rules! update_component_loops {
    ($self:expr, $store:expr, $change:expr, $time:expr) => {
{{#each components}}
    {{#if type}}
        for (entity_id, new) in $change.insertions.{{@key}}.iter() {
    {{else}}
        for entity_id in $change.insertions.{{@key}}.iter() {
    {{/if}}

            if let Some(position) = post_change_get!($store, $change, *entity_id, position) {

    {{#if fields.f64_total}}
                let old = if $change.removals.contains(*entity_id, ComponentType::{{name}}) {
                    0.0
                } else {
                    $store.{{@key}}.get(entity_id).map(Clone::clone).unwrap_or(0.0)
                };
                let increase = new - old;
                if let Some(mut cell) = $self.grid.get_mut(*position) {
                    cell.{{fields.f64_total.aggregate_name}} += increase;
                    cell.last_updated = $time;
                }
    {{/if}}
    {{#if fields.count}}
                if !$store.{{@key}}.{{#if type}}contains_key{{else}}contains{{/if}}(&entity_id) || $change.removals.contains(*entity_id, ComponentType::{{name}}) {
                    if let Some(mut cell) = $self.grid.get_mut(*position) {
                        cell.{{fields.count.aggregate_name}} += 1;
                        cell.last_updated = $time;
                    }
                }
    {{/if}}
    {{#if fields.set}}
                if !$store.{{@key}}.{{#if type}}contains_key{{else}}contains{{/if}}(&entity_id) || $change.removals.contains(*entity_id, ComponentType::{{name}}) {
                    if let Some(mut cell) = $self.grid.get_mut(*position) {
                        cell.{{fields.set.aggregate_name}}.insert(*entity_id);
                        cell.last_updated = $time;
                    }
                }
    {{/if}}
            }
        }
{{/each}}
    }
}

macro_rules! update_component_loops_ {
    ($self:expr, $store:expr, $change:expr, $time:expr) => {
{{#each components}}
        for (entity_id, change) in $change.{{@key}}.iter() {
            match change {
    {{#if type}}
                &DataChangeType::Insert(v) => {
        {{#if fields.f64_total}}
                    let old = $store.{{@key}}.get(entity_id).map(Clone::clone).unwrap_or(0.0);
                    let increase = v - old;
                    if let Some(position) = post_change_get_!($store, $change, *entity_id, position) {
                        if let Some(mut cell) = $self.grid.get_mut(*position) {
                            cell.{{fields.f64_total.aggregate_name}} += increase;
                            cell.last_updated = $time;
                        }
                    }
        {{/if}}
                }
                &DataChangeType::Remove => {
                }
    {{else}}
                &FlagChangeType::Insert => {
                }
                &FlagChangeType::Remove => {
                }
    {{/if}}
            }
        }
{{/each}}
    }
}
